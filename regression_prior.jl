################
### PREAMBLE ###
################

#TODO:
# - A. Core features
#   - 3. Allow for generating level assignments for random effects inside the Turing model
#      A. Make the RegressionPrior and its functions modular, so that one part samples hyperparameters, and another part samples random effects from the hyperparameters and provided level assignments
#   - 4. Allow for passing "nothing" instead of a LKJCholesky prior to specify that random effects in this block are uncorrelated
#   - 5. Overload for gradient compat: to_vec(), from_vec_transform(), to_linked_vec_transform(), from_linked_vec_transform()
# - B. Optimisation
#   - 1. Minimise use of DimensionalData where not needed
#   - 2. Ensure type stability
#   - 3. Pre-allocate random effect block assignments
# - C. Core Utilities
#   - 1. Make constructor function for RegressionPrior
#      A. Which construct multivariate distributions form individual priors_f
#      B. Which creates default priors or extrapolates single priors to full structure
#      C. Which checks that the inputs are all properly structured and matching
#   - 2. Make custom summary functionalities (FlexiChains & MCMCChains)
#   - 3. Make custom plotting functions (FlexiChains & MCMCChains)
# - D. Fixes
#   - 1. Add comments with canonical mathematical notation
#   - 2. Change naming of Cholesky factor
#   - 3. Allow empty fixed effects
#   - 4. Set full, concrete type requirements everywhere possible
#   - 5. Ensure that DualNumbers can be usued throughout
# - E. Functionality
#   - 1. unit tests
#   - 2. documentation
# - F. Usage
#   - 1. Fit the example Turing model with FlexiChains
#   - 2. Make example with Horseshoe priors.
#   - 3. Make example with Spike-and-slab priors.
#   - 4. Make example with latent mixture models with random effect factor level values or group assignments being latent variables
# - G. Near future features
#   - 1. Allow for discrete priors on fixed effects (e.g., spike-and-slab)
#   - 2. Allow for sharing parameters across regressions (e.g., fixed effects beign identical in multiple regressions)
#   - 3. Make constructor for combining multivariate distributions so that they sample vectors
#   - 4. add labels for categorical predictors
# - H. Extra
#   - 1. Make Turing submodel alternative to rand and logpdf (and benchmark)
#   - 2. Decide whether to store fixed effect and random effect sds as DimArrays or flat vectors internally
# - I. Long Future features
#   - 1. Structured random effects across levels (e.g., gaussian process, AR1, etc.)
#   - 2. Variance Component Analysis - letting random effect sd priors come from a multivariate distribution which can weigh between them. Would probably need to be all random effects from one big distribution.

### TERMINOLOGY ###
# - Regression (r): A single regression model. Multiple can be connected.
# - Fixed effect terms (p): The coefficients associated with the predictors (e.g., Intercept, Age, Gender).
# - Random effect factor (f): The identifier variable (e.g., SubjectID, ItemID).
# - Random effect levels (l): The unique instances within a factor (e.g., Subject 1, Subject 2).
# - Random effect groups (g): Sub-partitioning levels of a factor (Strata) for independent random effect variances and random effects (e.g., healthy vs. clinical). brms syntax: (1 | gr(subjID, by = diagnosis))
# - Random effect terms (q): The variables that vary across a factor (e.g., Intercept, Age, Gender). Is often collapsed across regressions to q_total.
# - Random effect blocks (b): Sets of random effect terms that are internally correlated (e.g., Intercept, Age, Gender). Blocks can be across regressions. brms syntax: (1 + age |p| subjID)
# - Observations (n): Each row in the data frame

### FUNCTIONALITY ###
# - multiple fixed effect terms (intercept and multiple predictors)
# - multiple random effect factors (e.g., subjects and items) with multiple random effect terms (intercept and multiple predictors)
# - grouped random effects (e.g., healthy vs. clinical subjects)
# - multiple regressions (e.g., multivariate outcomes)
# - random effect correlations within groups and between terms and regressions
# - multiple random effect correlation blocks within a factor
# - can use centered and non-centered parameterisations for random effects, on a per-factor basis
# - can update the predictors during the Turing model, so that predictors can be generated by other functions

### CONSTRAINTS ###
# - Random effect groups g must be applied across all regressions r 
# - Random effect levels l can only belong to a single group g within a factor f
# - There must be entries for each group in each factor for each regression. If a regression does not use a given factor, pass an empty vector instead of a vector with labels/priors for each term.
# - Random effect correlations must be specified for all terms across regressions but within a group and within a factor
# - I've made a hard assumption that the covariance matrices use a LKJCholesky prior, and not a LKJ for example.
# - We do not allow random effect blocks to be different within different random effect groups. Implementationally this would get difficult.
# - The priors over the fixed effects and random effect sds are multivariate distributions. If there is only a single fixed effect, this must still be a multivariate distribution, such as a one-dimensional MvNormal.

### POINTS OF UNCERTAINTY ###
# - adding the jitter to the covariance matrices when reconstructing them for logpdf calculations. Is this done right? How large should it be?

### DIFFERENCES TO brms ###
# - instead of the gr() syntax for grouping random effects, the grouping should perhaps be passed as a separate argument.
#   The reason is that a single factor must have the same grouping across all regressions.
#   We could also allow users to specify it in the brms way, but then we would need to check consistency across regressions.



###################################
### DISTRIBUTION IMPLEMENTATION ###
###################################

### SETUP ###
## For the regression distribution ##
using Distributions
using LinearAlgebra
using Random
using PDMats #This gives efficient computation for psitive definite matrices, used for the LKJCholesky stuff
using DimensionalData #This allows for named dimensions in arrays
using DimensionalData: @dim

## For the Turing model ##
using Turing
using FlexiChains

## Random effect parameterisation enum ##
@enum RandomEffectParameterization Centered NonCentered

## Dimension names ##
abstract type RegressionDimension{T} <: DimensionalData.Dimension{T} end
@dim RegressionDim RegressionDimension "Regression"                      #r
@dim FixedEffectTermDim RegressionDimension "Fixed Effect Term"          #p
@dim RandomEffectFactorDim RegressionDimension "Random Effect Factor"    #f
@dim RandomEffectTermDim RegressionDimension "Random Effect Term"        #q
@dim RandomEffectGroupDim RegressionDimension "Random Effect Group"      #g
@dim RandomEffectBlockDim RegressionDimension "Correlation Block"        #b
@dim RandomEffectLevelDim RegressionDimension "Random Effect Level"      #l
@dim ObservationDim RegressionDimension "Observation"                    #n


### CONTAINERS ###

## 1. Labels struct, containing labels for all components of the regression ##
struct RegressionLabels{
    Tregressions<:RegressionDim,
    Tfixed_effect_terms<:DimVector,
    Trandom_effect_factors<:RandomEffectFactorDim,
    Trandom_effect_terms<:DimVector,
    Trandom_effect_groups<:DimVector,
    Trandom_effect_blocks<:DimVector,
    Trandom_effect_levels<:DimVector
}

    #Vector (R regressions) of regression labels
    regressions::Tregressions

    #Vector (R regressions) of vectors (P fixed effect terms) of fixed effect labels
    fixed_effect_terms::Tfixed_effect_terms

    #Vector (F random effect factors) of factor labels
    random_effect_factors::Trandom_effect_factors

    #Vector (R regressions) of vectors (F random effect factors) of vectors (Q random effect terms) of random effect term labels
    random_effect_terms::Trandom_effect_terms

    #Vector (F random effect factors) of vectors (G random effect groups) of group labels
    random_effect_groups::Trandom_effect_groups

    #Vector (F random effect factors) of vectors (B random effect blocks) of block labels
    random_effect_blocks::Trandom_effect_blocks

    #Vector (F random effect factors) of vectors (J random effect levels) of level labels
    random_effect_levels::Trandom_effect_levels

end


## 2. Specifications struct, containing information about the model ##
struct RegressionSpecifications{Tgroups<:AbstractVector,Tblocks<:AbstractVector,Tparameterisations<:AbstractVector, Tfixed_effects<:AbstractVector,Trandom_effect_sds<:AbstractVector, Trandom_effect_sds_blocks<:AbstractVector}

    #Vector (F random effect factors) of vectors (L random effect levels) of group assignments (1:G)
    random_effect_group_assignments::Tgroups

    #Vector (R regressions) of vectors (F random effect factors) of vectors (Q_total random effect terms) of block assignments (1:B)
    random_effect_block_assignments::Tblocks

    #Vector (F random effect factors) of RandomEffectParameterization enums
    random_effect_parameterisations::Tparameterisations


    #Mapping from flat vector of fixed effect coefficients to its structured format
    fixed_effect_indices::Tfixed_effects

    #Mapping from flat vector of random effect SDs to its structured format
    random_effect_sds_indices::Trandom_effect_sds

    #Mapping from flat vector of random effect SDs to memberships in each random effect block
    random_effect_sds_block_indices::Trandom_effect_sds_blocks

    #Labels for components of the regression
    labels::RegressionLabels

end

## 3. Prior struct, distribution that coefficients can be sampled from ##
struct RegressionPriors{Tfixed<:MultivariateDistribution,Tsds<:MultivariateDistribution,Tcorrs<:AbstractVector,Tspecs<:RegressionSpecifications} <: ContinuousMultivariateDistribution

    #Multivariate distribution flattened from vector (R regressions) of multivariate priors (across P fixed effect terms)
    fixed_effects::Tfixed

    #Multivariate distribution flattened from vector (R regressions) of vectors (F Random effect factors) of vectors (G random effect groups) of vectors (Q random effect terms)
    random_effect_sds::Tsds

    #Vector (F random effect factors) of vectors (G random effect groups) of vectors (B random effect blocks) of LKJCholesky correlation priors
    random_effect_correlations::Tcorrs

    #Model specifications
    specifications::Tspecs
end

## 4. Coefficients struct ##
struct RegressionCoefficients{Tfixed<:AbstractVector,Tsds<:AbstractVector,Tcorrs<:AbstractVector,Tranef<:AbstractVector, Tspecs<:RegressionSpecifications}

    #Vector (R regressions) of vectors (P fixed effect terms) - flattened to a single vector
    fixed_effects_flat::Tfixed

    #Vector (R regressions) of vectors (F random effect factors) of vectors (G random effect groups) of vectors (Q random effect terms) - flattened to a single vector
    random_effect_sds_flat::Tsds

    #Vector (F random effect factors) of vectors (G random effect groups) of vectors (B random effect blocks) of Cholesky correlations (Q_total random effect terms, Q_total random effect terms)
    random_effect_correlations::Tcorrs

    #Vector (F random effect factors) of matrices (J random effect levels, Q_total random effect terms)
    #Stores actual values or z-scores for centered and non-centered parameterisations respectively
    random_effects::Tranef

    #Model specifications
    specifications::Tspecs
end

### DISTRIBUTION FUNCTIONS ###

## 1. Sampling function ##
function Distributions.rand(rng::AbstractRNG, d::D) where {D<:RegressionPriors}

    ## 0. Extract information ##
    specifications = d.specifications
    labels = specifications.labels

    ## 1. Sample all fixed effects p for each regression r ##
    fixed_effects_flat = rand(rng, d.fixed_effects)
    
    ## 2. Sample random effect standard deviations for each term q in each group g per factor f in regression r ##
    random_effect_sds_flat = rand(rng, d.random_effect_sds)

    ## 3. Sample the random effect correlations ## 
    random_effect_correlations = DimArray([
            DimArray([
                    DimArray([
                            rand(rng, d.random_effect_correlations[At(f)][At(g)][At(b)])
                            for b in labels.random_effect_blocks[At(f)]],
                        labels.random_effect_blocks[At(f)])
                    for g in labels.random_effect_groups[At(f)]
                ], labels.random_effect_groups[At(f)])
            for f in labels.random_effect_factors
        ], labels.random_effect_factors)

    ## 4. Sample the random effects themselves, factor by factor ## 
    #Initialise storage for random effect values
    random_effects = DimArray(Vector{DimArray{Float64,2,<:Tuple{RandomEffectLevelDim,RandomEffectTermDim}}}(undef, length(labels.random_effect_factors)), labels.random_effect_factors) #CURRENTLY HERE

    #Go through each factor f
    for f in labels.random_effect_factors

        # 4.0 setup
        #Extract information about factor f
        group_assignments_f = specifications.random_effect_group_assignments[At(f)]
        parameterisation_f = specifications.random_effect_parameterisations[At(f)]

        random_effect_block_labels_f = labels.random_effect_blocks[At(f)]
        random_effect_group_labels_f = labels.random_effect_groups[At(f)]
        random_effect_level_labels_f = labels.random_effect_levels[At(f)]
        random_effect_term_labels_f = RandomEffectTermDim(vcat([parent(labels.random_effect_terms[At(r)][At(f)]) for r in labels.regressions]...))

        #Initialise empty random effects matrix for factor f
        random_effects_f = DimArray(
            zeros(length(random_effect_level_labels_f), length(random_effect_term_labels_f)),
            (random_effect_level_labels_f, random_effect_term_labels_f)
        )

        #Go through every random effect group g
        for g in random_effect_group_labels_f

            # 4.1 Find levels belonging to this group
            random_effect_level_labels_g = random_effect_level_labels_f[group_assignments_f .== g]

            #Go through every block b
            for b in random_effect_block_labels_f

                # 4.2 extract random effect terms for this block b
                #Initialise storage
                random_effect_term_labels_b = []
                #For each regression r
                for r in labels.regressions
                    #Extract block assignments for this regression and factor
                    random_effect_block_assignments_f = specifications.random_effect_block_assignments[At(r)][At(f)]
                    #For each random effect term q
                    for q in dims(random_effect_block_assignments_f, RandomEffectTermDim)
                        #If the term belongs to this block
                        if random_effect_block_assignments_f[At(q)] == b
                            #Store its label
                            push!(random_effect_term_labels_b, q)
                        end
                    end
                end
                
                # 4.3 If there are no terms in this block, skip to next block
                isempty(random_effect_term_labels_b) && continue

                #For non-centered parameterisations
                if parameterisation_f == NonCentered

                    # 4.4 Sample random effects as z-scores for this block
                    #Go through each level l
                    for l in random_effect_level_labels_g
                        #Sample random effect z-scores from a standard normal
                        random_effects_f[At(l), At(parent(random_effect_term_labels_b))] = randn(rng, length(random_effect_term_labels_b))
                    end

                    #For centered parameterisations
                elseif parameterisation_f == Centered

                    # 4.5 extract random effect sds for this block
                    sds_b = view(random_effect_sds_flat, specifications.random_effect_sds_block_indices[At(f)][At(g)][At(b)])

                    # 4.6 extract random effect correlations for this block
                    random_effect_correlations_b = random_effect_correlations[At(f)][At(g)][At(b)]

                    # 4.7 Construct random effect covariances for this block
                    random_effect_covariances_b = Diagonal(sds_b) * random_effect_correlations_b.L

                    # 4.8 Sample random effects for this block
                    #Go through each level l
                    for l in random_effect_level_labels_g
                        #Sample random effects for this block (multiply the Cholesky factor with standard normal samples)
                        random_effects_f[At(l), At(parent(random_effect_term_labels_b))] = random_effect_covariances_b * randn(rng, length(random_effect_term_labels_b))
                    end
                end
            end
        end

        #Store the random effects matrix for this factor
        random_effects[At(f)] = random_effects_f
    end

    return RegressionCoefficients(fixed_effects_flat, random_effect_sds_flat, random_effect_correlations, random_effects, specifications)
end

## 2. Logpdf function ##
function Distributions.logpdf(d::D, x::T) where {D<:RegressionPriors,T<:RegressionCoefficients}

    ## 0. Setup ##
    # Extract information
    specifications = d.specifications
    labels = specifications.labels
    #Initialise logprob
    logprob = 0.0

    ## 1. Add logprob of each fixed effect term p across regressions r ##
    logprob += logpdf(d.fixed_effects, x.fixed_effects_flat)

    ## 2. Add logprob of SDs of each random effect term, across group, factors and regressions ##
    logprob += logpdf(d.random_effect_sds, x.random_effect_sds_flat)

    ## 3. Add logprob for random effects for each group in each factor ##
    #Go through each factor f
    for f in labels.random_effect_factors

        # 3.0 Setup ##
        #Extract information about factor f
        group_assignments_f = specifications.random_effect_group_assignments[At(f)]
        parameterisation_f = specifications.random_effect_parameterisations[At(f)]

        #Go through every group g
        for g in labels.random_effect_groups[At(f)]

            # 3.1 Identify levels belonging to this group
            random_effect_levels_g = labels.random_effect_levels[At(f)][group_assignments_f .== g]

            # Go through every correlation block b
            for b in labels.random_effect_blocks[At(f)]

                # 3.3 extract random effect correlations, and add logprob
                random_effect_correlations_b = x.random_effect_correlations[At(f)][At(g)][At(b)]
                logprob += logpdf(d.random_effect_correlations[At(f)][At(g)][At(b)], random_effect_correlations_b)


                # 3.4 Extract random effect terms for this block across all regressions
                #Initialise storage
                random_effect_term_labels_b = Symbol[]
                #For each regression r
                for r in labels.regressions
                    #Extract block assignments for this regression and factor
                    random_effect_block_assignments_f = specifications.random_effect_block_assignments[At(r)][At(f)]
                    #For each random effect term q
                    for q in dims(random_effect_block_assignments_f, RandomEffectTermDim)
                        #If the term belongs to this block
                        if random_effect_block_assignments_f[At(q)] == b
                            #Store its label
                            push!(random_effect_term_labels_b, q)
                        end
                    end
                end

                # 3.5 If there are no terms in this block, skip to next block
                isempty(random_effect_term_labels_b) && continue

                #For non-centered parameterisations
                if parameterisation_f == NonCentered

                    # 3.6 Extract random effect z-scores for this block and group
                    z_scores_b = x.random_effects[At(f)][At(parent(random_effect_levels_g)), At(parent(random_effect_term_labels_b))]

                    # 3.7 Add logprobs for random effect z-scores, using a standard normal
                    logprob += sum(logpdf.(Normal(0, 1), z_scores_b))

                elseif parameterisation_f == Centered #for centered parameterisations

                    # 3.8 extract random effect sds for this block
                    sds_b = view(x.random_effect_sds_flat, specifications.random_effect_sds_block_indices[At(f)][At(g)][At(b)])

                    # 3.9 Reconstruct block covariance and random effect distribution
                    L = random_effect_correlations_b.L
                    random_effect_covariances_b = Diagonal(sds_b) * (L * L') * Diagonal(sds_b)
                    random_effect_covariances_b = PDMat(Symmetric(Matrix(random_effect_covariances_b + 1e-8 * I)))
                    dist_b = MvNormal(zeros(length(sds_b)), random_effect_covariances_b)

                    # 3.10 Add logprobs for random effects in this block
                    #Extract the random effects for this block [Levels x Terms]
                    random_effects_b = x.random_effects[At(f)][At(parent(random_effect_levels_g)), At(random_effect_term_labels_b)]
                    #Add logprobs for all random effects in this block
                    logprob += sum(logpdf(dist_b, collect(parent(random_effects_b)')))
                end
            end
        end
    end

    return logprob
end




#########################
### UTILITY FUNCTIONS ###
#########################

## 1. Unflattening function for fixed effects ##
function unflatten_fixed_effects(fixed_effects_flat::Vector{R}, specifications::RegressionSpecifications) where {R<:Real}

    # Extract information
    labels = specifications.labels

    # Structure fixed effects properly, and add labels
    fixed_effects = DimArray([
        DimArray(
            view(fixed_effects_flat, specifications.fixed_effect_indices[At(r)]),
            labels.fixed_effect_terms[At(r)]
        )
        for r in labels.regressions
    ], labels.regressions)

    return fixed_effects

end

## 2. Unflattening function for random effect sds ##
function unflatten_random_effect_sds(random_effect_sds_flat::Vector{R}, specifications::RegressionSpecifications) where {R<:Real}

    # Extract information
    labels = specifications.labels

    # Structure random effect sds properly, and add labels
    random_effect_sds = DimArray([
        DimArray([
            DimArray([
                DimArray(
                    view(random_effect_sds_flat, specifications.random_effect_sds_indices[At(r)][At(f)][At(g)]),
                    labels.random_effect_terms[At(r)][At(f)]
                )
                for g in labels.random_effect_groups[At(f)]
            ], labels.random_effect_groups[At(f)]) 
            for f in labels.random_effect_factors
        ], labels.random_effect_factors) 
        for r in labels.regressions
    ], labels.regressions)

    return random_effect_sds

end


## 3. Getter function for the fixed effects ##
function get_fixed_effects(coefficients::RegressionCoefficients)

    #Unflatten and return fixed effects
    return unflatten_fixed_effects(coefficients.fixed_effects_flat, coefficients.specifications)

end


## 4. Materialiser function for getting actual random effects irrespective of parameterisation ##
function get_random_effects(coefficients::Tcoefs) where {Tcoefs<:RegressionCoefficients}

    ## 0. Setup ##
    #Extract information
    specifications = coefficients.specifications
    labels = specifications.labels

    #Initialise storage
    random_effects = DimArray(
        Vector{DimArray{Float64, 2}}(undef, length(labels.random_effect_factors)), 
        labels.random_effect_factors
    )

    #Go through each factor
    for f in labels.random_effect_factors

        ## 0.0 Setup ##
        unprocessed_random_effects_f = coefficients.random_effects[At(f)]
        parameterisation_f = specifications.random_effect_parameterisations[At(f)]

        # 1 Process centered parameterisations
        if parameterisation_f == Centered

            # 1.1 Copy the random effects, since they are already actual values
            random_effects[At(f)] = copy(unprocessed_random_effects_f)

        # 2 Process non-centered parameterisations
        elseif parameterisation_f == NonCentered

            # 2.0 Setup
            #Extract information
            group_assignments_f = specifications.random_effect_group_assignments[At(f)]
            random_effect_level_labels_f = labels.random_effect_levels[At(f)]
            random_effect_term_labels_f = RandomEffectTermDim(vcat([parent(labels.random_effect_terms[At(r)][At(f)]) for r in labels.regressions]...))

            #Initialise storage for processed random effects
            processed_random_effects_f = DimArray(
                zeros(size(unprocessed_random_effects_f)), 
                (random_effect_level_labels_f, random_effect_term_labels_f)
            )

            #Go through every group g
            for g in labels.random_effect_groups[At(f)]

                # 2.1 Identify levels belonging to this group
                random_effect_levels_g = parent(random_effect_level_labels_f[group_assignments_f .== g])

                #Go through every block b
                for b in labels.random_effect_blocks[At(f)]

                    # 2.2 Identify random effect terms and SDs for this block
                    #Initialise storage
                    random_effect_term_labels_b = []
                    #For each regression r
                    for r in labels.regressions
                        #Extract block assignments for this regression and factor
                        random_effect_block_assignments_f = specifications.random_effect_block_assignments[At(r)][At(f)]
                        #For each random effect term q
                        for q in dims(random_effect_block_assignments_f, RandomEffectTermDim)
                            #If the term belongs to this block
                            if random_effect_block_assignments_f[At(q)] == b
                                #Store its label
                                push!(random_effect_term_labels_b, q)
                            end
                        end
                    end

                    # 2.3 If there are no terms in this block, skip to next block
                    isempty(random_effect_term_labels_b) && continue

                    # 2.4 extract random effect sds for this block
                    sds_b = view(coefficients.random_effect_sds_flat, specifications.random_effect_sds_block_indices[At(f)][At(g)][At(b)])

                    # 2.4 Reconstruct random effect covariances for this block
                    random_effect_covariances_b = Diagonal(sds_b) * coefficients.random_effect_correlations[At(f)][At(g)][At(b)].L

                    # 2.5 transform z-scored random effects to actual random effects, and store them
                    processed_random_effects_f[At(random_effect_levels_g), At(random_effect_term_labels_b)] = unprocessed_random_effects_f[At(random_effect_levels_g), At(random_effect_term_labels_b)] * random_effect_covariances_b'

                end
            end
            #Store the processed random effects for this factor
            random_effects[At(f)] = processed_random_effects_f
        end
    end

    return random_effects
end


## 5. Function for generating indices mapping from the flattened coefficient vectors to structured representationjs and block assignments ##
function generate_indices(labels::RegressionLabels, random_effect_block_assignments::T) where {T<:AbstractVector}

    ## Fixed effects ##
    fixed_effect_indices = DimArray(
        Vector{UnitRange{Int}}(undef, length(labels.regressions)), 
        labels.regressions
    )
    curr_idx = 1
    for r in labels.regressions
        n_terms = length(labels.fixed_effect_terms[At(r)])
        fixed_effect_indices[At(r)] = curr_idx:(curr_idx + n_terms - 1)
        curr_idx += n_terms
    end

    ## Random effect SDs ##
    random_effect_sds_indices = DimArray([
        DimArray([
            DimArray(
                Vector{UnitRange{Int}}(undef, length(labels.random_effect_groups[At(f)])), 
                labels.random_effect_groups[At(f)]
            )
            for f in labels.random_effect_factors
        ], labels.random_effect_factors)
        for r in labels.regressions
    ], labels.regressions)
    curr_idx = 1
    for r in labels.regressions
        for f in labels.random_effect_factors
            for g in labels.random_effect_groups[At(f)]
                n_terms = length(labels.random_effect_terms[At(r)][At(f)])
                random_effect_sds_indices[At(r)][At(f)][At(g)] = curr_idx:(curr_idx + n_terms - 1)
                curr_idx += n_terms
            end
        end
    end

    ## Random effect SDs -> block indices ##
    random_effect_sds_block_indices = DimArray([
        DimArray([
            DimArray([
                # Collect absolute indices across all regressions
                reduce(vcat, [
                    begin
                        r_f_g_range = random_effect_sds_indices[At(r)][At(f)][At(g)]
                        
                        # Find which terms in this Regression-Factor belong to block 'b'
                        # parent() is used to get the raw vector of block symbols
                        local_indices = findall(==(b), parent(random_effect_block_assignments[At(r)][At(f)]))
                        
                        # If local_indices is empty or the range is empty (1:0), 
                        # we return an empty Int vector.
                        if isempty(local_indices) || isempty(r_f_g_range)
                            Int[]
                        else
                            # Map local term indices to absolute indices in the flat vector
                            # We take the start of the range and add the local offsets
                            # local_indices are 1-based, so subtract 1
                            collect((r_f_g_range.start - 1) .+ local_indices)
                        end
                    end
                    for r in labels.regressions
                ])
                for b in labels.random_effect_blocks[At(f)]
            ], labels.random_effect_blocks[At(f)])
            for g in labels.random_effect_groups[At(f)]
        ], labels.random_effect_groups[At(f)])
        for f in labels.random_effect_factors
    ], labels.random_effect_factors)

    return (fixed_effect_indices, random_effect_sds_indices, random_effect_sds_block_indices)

end



################################
### EVALUATION: DISTRIBUTION ###
################################

## Labels ##
#Names for the different regressions
regression_labels = RegressionDim([:Regression1, :Regression2])

#Names for the fixed effect terms in each regression
fixed_effect_term_labels = DimArray([
        #Regression 1
        FixedEffectTermDim([:Term1, :Term2, :Term3]),
        #Regression 2
        FixedEffectTermDim([:Term1, :Term2, :Term3, :Term4, :Term5])
    ], regression_labels)

#Names for the random effect factors
random_effect_factor_labels = RandomEffectFactorDim([:SubjectFactor, :ItemFactor])

#Names and structure of random effect terms in each regression and factor
random_effect_term_labels = DimArray([
        #Regression 1
        DimArray([
                #Factor 1
                RandomEffectTermDim([:Term1, :Term2]),
                #Factor 2
                RandomEffectTermDim([:Term1])
            ], random_effect_factor_labels),
        #Regression 2
        DimArray([
                #Factor 1
                RandomEffectTermDim([:Term1, :Term2, :Term3]),
                #Factor 2
                RandomEffectTermDim([])
            ], random_effect_factor_labels)
    ], regression_labels)

#Names and structure of random effect groups in each factor
random_effect_group_labels = DimArray([
        #Factor 1
        RandomEffectGroupDim([:f1_HealthyGroup, :f1_SickGroup]),
        #Factor 2
        RandomEffectGroupDim([:f2_AllItemsGroup])
    ], random_effect_factor_labels)

#Names and structure of random effect correlation blocks in each factor
random_effect_block_labels = DimArray([
        #Factor 1
        RandomEffectBlockDim([:f1_Block1, :f1_Block2]),
        #Factor 2
        RandomEffectBlockDim([:f2_Block1])
    ], random_effect_factor_labels)

#Names for individual random effect levels in each factor
random_effect_level_labels = DimArray([
        #Factor 1
        RandomEffectLevelDim([:Subj1, :Subj2, :Subj3, :Subj4]),
        #Factor 2
        RandomEffectLevelDim([:Item1, :Item2, :Item3])
    ], random_effect_factor_labels)

## Regression 1 ##
# 3 fixed effect terms P
# 2 Random effect factors F
#    - Factor 1: 2 groups G, 2 terms Q
#    - Factor 2: 1 group G, 1 term Q

#Fixed effect priors
r1_fixed = DimArray(
    [Normal(0, 1), Normal(0, 1), Normal(0, 1)], 
    fixed_effect_term_labels[At(regression_labels[1])]
)

#Random effect SD priors
r1_sds = DimArray([

    #Factor 1, with 2 terms
    DimArray([
        # Group 1
        DimArray([Gamma(2, 0.1), Gamma(2, 0.1)], random_effect_term_labels[At(regression_labels[1])][At(random_effect_factor_labels[1])]),
        # Group 2
        DimArray([Gamma(2, 0.5), Gamma(2, 0.5)], random_effect_term_labels[At(regression_labels[1])][At(random_effect_factor_labels[1])]),

    ], random_effect_group_labels[At(random_effect_factor_labels[1])]),
    #Factor 2, with 1 term
    DimArray([

        # Group 1
        DimArray([Gamma(2, 0.1)], random_effect_term_labels[At(regression_labels[1])][At(random_effect_factor_labels[2])]),

    ], random_effect_group_labels[At(random_effect_factor_labels[2])]),
], random_effect_factor_labels)

## Regression 2 ##
# 5 fixed effect terms P
# 2 Random effect factors F
#    - Factor 1: 2 groups G, 3 terms Q
#    - Factor 2: 1 groups G, 0 terms Q

#Fixed effect priors
r2_fixed = DimArray(
    [Normal(0, 1), Normal(0, 1), Normal(0, 1), Normal(0, 1), Normal(0, 1)], 
    fixed_effect_term_labels[At(regression_labels[2])]
)

#Random effect SD priors
r2_sds = DimArray([

    #Factor 1, with 3 terms
    DimArray([
        
        # Group 1
        DimArray([Gamma(2, 0.1), Gamma(2, 0.1), Gamma(2, 0.1)], random_effect_term_labels[At(regression_labels[2])][At(random_effect_factor_labels[1])]),
        # Group 2
        DimArray([Gamma(2, 0.5), Gamma(2, 0.5), Gamma(2, 0.1)], random_effect_term_labels[At(regression_labels[2])][At(random_effect_factor_labels[1])]),

    ], random_effect_group_labels[At(random_effect_factor_labels[1])]),
    #Factor 2, with 0 terms (not used in the regression)
    DimArray([

        # Group 1
        DimArray(Gamma{Float64}[], random_effect_term_labels[At(regression_labels[2])][At(random_effect_factor_labels[2])]),

    ], random_effect_group_labels[At(random_effect_factor_labels[2])]),

], random_effect_factor_labels)


## Random effect correlation priors ##
#Factor 1: 2 groups, 5 total terms across regressions (Reg 1: 2, Reg 2: 3). Block 1 has terms 1-2, block 2 has terms 3-5.
#Factor 2: 1 group, 1 total term across regressions (Reg 1: 1, Reg 2: 0). Block 1 has has term 1.

f1_cor_priors = DimArray([
    #Group 1
    DimArray([
        #Block 1
        LKJCholesky(2, 1.0),
        #Block 2
        LKJCholesky(3, 1.0)
    ], random_effect_block_labels[At(random_effect_factor_labels[1])]),

    #Group 2
    DimArray([
        #Block 1
        LKJCholesky(2, 1.0),
        #Block 2
        LKJCholesky(3, 1.0)
    ], random_effect_block_labels[At(random_effect_factor_labels[1])]),
], random_effect_group_labels[At(random_effect_factor_labels[1])])


f2_cor_priors = DimArray([
    #Group 1
    DimArray([
        #Block 1
        LKJCholesky(1, 1.0),
    ], random_effect_block_labels[At(random_effect_factor_labels[2])])
], random_effect_group_labels[At(random_effect_factor_labels[2])])

## Random effect group assignments ##
# Factor 1: 4 subjects (2 Healthy, 2 Sick)
# Factor 2: 3 items (All 1 group)
group_assignments = DimArray([
    #Factor 1
    DimArray([:f1_HealthyGroup, :f1_HealthyGroup, :f1_SickGroup, :f1_SickGroup], random_effect_level_labels[At(random_effect_factor_labels[1])]),
    #Factor 2
    DimArray([:f2_AllItemsGroup, :f2_AllItemsGroup, :f2_AllItemsGroup], random_effect_level_labels[At(random_effect_factor_labels[2])])
], random_effect_factor_labels)

## Random effect term block assignments ##
# Regression 1
#  - Factor 1: Terms 1 and 2 in Block 1
#  - Factor 2: Term 1 in Block 1
# Regression 2
#  - Factor 1: Terms 1, 2, and 3 in Block 2
#  - Factor 2: Not used
block_assignments = DimArray([
    # Regression 1
    DimArray([
        # Factor 1: Subject. Term 1 and 2 in Block 1
        DimArray([:f1_Block1, :f1_Block1], random_effect_term_labels[At(:Regression1)][At(:SubjectFactor)]),
        # Factor 2: Item. Term 1 in Block 1
        DimArray([:f2_Block1], random_effect_term_labels[At(:Regression1)][At(:ItemFactor)])
    ], random_effect_factor_labels),

    # Regression 2
    DimArray([
        # Factor 1: Subject. Term 1, 2, 3 in Block 2
        DimArray([:f1_Block2, :f1_Block2, :f1_Block2], random_effect_term_labels[At(:Regression2)][At(:SubjectFactor)]),
        # Factor 2: Item. Not used
        DimArray(Symbol[], random_effect_term_labels[At(:Regression2)][At(:ItemFactor)])
    ], random_effect_factor_labels)
], regression_labels)

## Random effect parameterisations ##
# Factor 1: Non-centered
# Factor 2: Centered
random_effect_parameterisations = DimArray([
    #Factor 1
    NonCentered,
    #Factor 2
    Centered
], random_effect_factor_labels)

#Final structuring of information
fixed_effect_priors = DimArray([r1_fixed, r2_fixed], regression_labels)
random_effect_sd_priors = DimArray([r1_sds, r2_sds], regression_labels)
correlation_priors = DimArray([f1_cor_priors, f2_cor_priors], random_effect_factor_labels)



## Collect individual priors into multivariate priors ##
#Fixed effects
fixed_effect_priors_gathered = product_distribution([prior_p for priors_r in fixed_effect_priors for prior_p in priors_r])
#Random effect SDs
random_effect_sd_priors_gathered = product_distribution([prior_q for priors_r in random_effect_sd_priors for priors_f in priors_r for priors_g in priors_f for prior_q in priors_g])


## Initialise labels ##
labels = RegressionLabels(
    regression_labels,
    fixed_effect_term_labels,
    random_effect_factor_labels,
    random_effect_term_labels,
    random_effect_group_labels,
    random_effect_block_labels,
    random_effect_level_labels
)

## Generate indices for mapping from flattened vector to structured coefficients
(fixed_effect_indices, random_effect_sds_indices, random_effect_sds_block_indices) = generate_indices(labels, block_assignments)

## Initialise specifications and priors ##
regression_specifications = RegressionSpecifications(group_assignments, block_assignments, random_effect_parameterisations, fixed_effect_indices, random_effect_sds_indices, random_effect_sds_block_indices, labels)
priors = RegressionPriors(fixed_effect_priors_gathered, random_effect_sd_priors_gathered, correlation_priors, regression_specifications)


## Execute ##
coeffs = rand(priors)
total_logprob = logpdf(priors, coeffs)
fixed_effects = get_fixed_effects(coeffs)
random_effects = get_random_effects(coeffs)




#######################
### FULL REGRESSION ###
#######################

### STRUCTS ###
## 1. Predictors struct ##
struct RegressionPredictors{Tfixedeffects<:DimArray, Trandomeffects<:DimArray, Tlevels<:DimArray}
    #Vector (R regressions) of fixed effect design matrices (N observations x P fixed effect terms)
    fixed_effect_design_matrices::Tfixedeffects

    #Vector (R regressions) of Vector (F factors) of random effect design matrices (N observations x Q random effect terms)
    random_effect_design_matrices::Trandomeffects

    #Vector (R regressions) of vectors (F factors) of vectors (N observations) of level labels
    #Mapping each observation to its random effect level (e.g., Subject 1, Item 2)
    random_effect_level_assignments::Tlevels
end

### LINEAR PREDICTION FUNCTION ###
## 2. Function for calculating outcomes for a single regression ##
function linear_prediction(; 
    fixed_effects::Tfixed_effects,
    random_effects::Trandom_effects, 
    fixed_effect_design_matrix::Tfixed_effects_design_matrix, 
    random_effect_design_matrices::Trandom_effect_design_matrices, 
    random_effect_level_assignments::Trandom_effect_level_assignments, 
    random_effect_term_labels::Trandom_effect_term_labels
    ) where {
        Tfixed_effects, Trandom_effects, Tfixed_effects_design_matrix, Trandom_effect_design_matrices, Trandom_effect_level_assignments, Trandom_effect_term_labels
    }

    # 1. Extract labels for the observations in this regression
    observation_labels = dims(fixed_effect_design_matrix, ObservationDim)

    # 2. Multiply the fixed effect design matrix with the fixed effects
    outcomes = parent(fixed_effect_design_matrix) * parent(fixed_effects)

    #Go through each factor
    for f in labels.random_effect_factors

        # 3. Extract labels for of random effect terms for this factor f
        random_effect_term_labels_f = random_effect_term_labels[At(f)]

        # 4. If there are no random effect terms for this factor, skip to next factor
        isempty(random_effect_term_labels_f) && continue

        # 5. Extract random effects for this factor f and these levels l
        random_effect_level_assignments_f = random_effect_level_assignments[At(f)]
        random_effects_l = random_effects[At(f)][At(parent(random_effect_level_assignments_f)), At(parent(random_effect_term_labels_f))]

        # 6. Extract random effect design matrix for this regression r and factor f
        random_effect_design_matrix_f = random_effect_design_matrices[At(f)]

        # 7. Multiply random effect design matrix with random effects
        outcomes .+= sum(parent(random_effect_design_matrix_f) .* parent(random_effects_l), dims=2)
    end

    return DimArray(vec(outcomes), observation_labels)

end

## Medium-level functions for simplifying input, by allowing inputting the predictors as a single object ##
function linear_prediction(
    fixed_effects::Tfixed_effects,
    random_effects::Trandom_effects, 
    predictors::Tpredictors,
    labels::Tlabels,
    r::Symbol
    ) where {
        Tfixed_effects, Trandom_effects, Tpredictors<:RegressionPredictors, Tlabels<:RegressionLabels
    }

    return linear_prediction(
        fixed_effects = fixed_effects[At(r)], 
        random_effects = random_effects, 
        fixed_effect_design_matrix = predictors.fixed_effect_design_matrices[At(r)],
        random_effect_design_matrices = predictors.random_effect_design_matrices[At(r)],
        random_effect_level_assignments = predictors.random_effect_level_assignments[At(r)],
        random_effect_term_labels = labels.random_effect_terms[At(r)],
    )
end

## Medium-level functions for simplifying input, by allowing inputting specifications instead of labels ##
function linear_prediction(
    fixed_effects::Tfixed_effects,
    random_effects::Trandom_effects, 
    predictors::Tpredictors,
    specifications::Tspecifications,
    r::Symbol
    ) where {
        Tfixed_effects, Trandom_effects, Tpredictors<:RegressionPredictors, Tspecifications<:RegressionSpecifications
    }

    return linear_prediction(
        fixed_effects,
        random_effects, 
        predictors.labels,
        specifications,
        r
    )
end

## 3. High-level unction for calculating outcomes across a set of regressions ##
function linear_prediction(predictors::Tpredictors, coefficients::Tcoefficients) where {Tpredictors<:RegressionPredictors,Tcoefficients<:RegressionCoefficients}

    ## 0. Setup ##
    #Extract information
    labels = coefficients.specifications.labels

    #Extract coefficients
    #Vector (R regressions) of vectors (P fixed effect terms)
    fixed_effects = get_fixed_effects(coefficients)
    #Vector (R regressions) of vectors (F factors) of matrices (J random effect levels, Q_total random effect terms)
    random_effects = get_random_effects(coefficients)

    #Calculate the linear predictions for each regression
    outcomes = DimArray([
        linear_prediction(
            fixed_effects, 
            random_effects, 
            predictors, 
            labels, 
            r, 
        )
        for r in labels.regressions
    ], labels.regressions)

    return outcomes
end


### UTILITY FUNCTIONS ###
## 4. Function for updating a term in all regressions ##
function update_predictor(predictors::Tpredictors, values::Tvalues, term::Symbol) where {Tpredictors<:RegressionPredictors, Tvalues<:AbstractVector}

    #Update each regression one at a time
    return foldl((predictors_r, r) -> update_predictor(predictors_r, values, term, r), 
          val(dims(predictors.fixed_effect_design_matrices, RegressionDim)), 
          init = predictors)

end

## 5. Function for updating a term in a single regression ##
function update_predictor(predictors::Tpredictors, values::Tvalues, term::Symbol, r::Symbol) where {Tpredictors<:RegressionPredictors, Tvalues<:AbstractVector}
    
    ## 0. Extract information ##
    fixed_effect_design_matrices = predictors.fixed_effect_design_matrices
    random_effect_design_matrices = predictors.random_effect_design_matrices
    
    ## 1. Update fixed effects ##
    #Extract regression-specific matrix
    fixed_effect_design_matrix_r = fixed_effect_design_matrices[At(r)]
    #Update it
    updated_fixed_effect_design_matrix_r = update_design_matrix(fixed_effect_design_matrix_r, values, term)

    ## 2. Update random effects ##
    #Extract regression-specific matrices
    random_effect_design_matrices_r = random_effect_design_matrices[At(r)]

    #Make new copy of the vector containing the matrices
    updated_random_effect_design_matrices_r = copy(parent(random_effect_design_matrices_r))

    #Go through each factor f
    for idx_f in eachindex(dims(random_effect_design_matrices_r, RandomEffectFactorDim))

        #Replace the matrix with an updated matrix
        updated_random_effect_design_matrices_r[idx_f] = update_design_matrix(random_effect_design_matrices_r[idx_f], values, term)
    end

    #Rebuild the DimArray containing the vectors
    updated_random_effect_design_matrices_r = rebuild(random_effect_design_matrices_r, updated_random_effect_design_matrices_r)

    ## 3. Make copies of design matrix containers ##
    #Get regression integer index
    regression_idx = findfirst(==(r), val(dims(predictors.fixed_effect_design_matrices, RegressionDim)))

    #Copy original containers
    new_fixed_effect_design_matrices = copy(parent(fixed_effect_design_matrices))
    new_random_effect_design_matrices = copy(parent(random_effect_design_matrices))

    #Replace the matrices for the specific regression
    new_fixed_effect_design_matrices[regression_idx] = updated_fixed_effect_design_matrix_r
    new_random_effect_design_matrices[regression_idx] = updated_random_effect_design_matrices_r

    #Rebuild to make sure the format of the containers is identical
    new_fixed_effect_design_matrices = rebuild(fixed_effect_design_matrices, new_fixed_effect_design_matrices)
    new_random_effect_design_matrices = rebuild(random_effect_design_matrices, new_random_effect_design_matrices)
    
    ## 3. Return a new predictor struct ##
    return RegressionPredictors(
        new_fixed_effect_design_matrices,
        new_random_effect_design_matrices,
        predictors.random_effect_level_assignments
    )
end

## 6. Function for replacing a column in a design matrix ##
function update_design_matrix(design_matrix::Tmatrix, values::Tvalues, term::Symbol) where {Tmatrix <: AbstractMatrix, Tvalues <: AbstractVector}
    
    #If the term exists in the design matrix
    if term in val(dims(design_matrix, 2))

        #Find the column index of the term in the design matrix
        term_idx = findfirst(==(term), val(dims(design_matrix, 2)))

        #Return a new design matrix where the target column has been replaced
        return rebuild(design_matrix, hcat(parent(design_matrix)[:, 1:term_idx-1], values, parent(design_matrix)[:, term_idx+1:end]))

    else #If the term does not exist

        #Use the old design matrix
        return design_matrix
    end
end


## 7. In-place function for updating a term in all regressions ##
function update_predictor!(predictors::Tpredictors, values::Tvalues, term::Symbol) where {Tpredictors<:RegressionPredictors, Tvalues<:AbstractVector}

    #For each regression r
    for r in val(dims(predictors.fixed_effect_design_matrices, RegressionDim))

        #Update the predictor in that regression
        update_predictor!(predictors, values, term, r)

    end

    return nothing
end


## 8. In-place function for updating a term in a single regression ##
function update_predictor!(predictors::Tpredictors, values::Tvalues, term::Symbol, r::Symbol) where {Tpredictors<:RegressionPredictors, Tvalues<:AbstractVector}
    
    #Update fixed effects
    fixed_effect_design_matrix_r = predictors.fixed_effect_design_matrices[At(r)]
    update_design_matrix!(fixed_effect_design_matrix_r, values, term)

    #Update random effects
    random_effect_design_matrices_r = predictors.random_effect_design_matrices[At(r)]
    for f in dims(random_effect_design_matrices_r, RandomEffectFactorDim)
        update_design_matrix!(random_effect_design_matrices_r[At(f)], values, term)
    end

    return nothing
end


## 9. In-place function for replacing a column in a design matrix ##
function update_design_matrix!(design_matrix::Tmatrix, values::Tvalues, term::Symbol) where {Tmatrix <: AbstractMatrix, Tvalues <: AbstractVector}
    
    #If the term exists in the design matrix
    if term in val(dims(design_matrix, 2))

        #Update the values in the column
        design_matrix[:, At(term)] .= values

    end

    return nothing
end


#######################################
### EVALUATION: REGRESSION FUNCTION ###
#######################################
using Random
Random.seed!(123)

# 1. Setup Observation IDs
N = 12
# Mapping observations to Subject (1-4) and Item (1-3)


subj_idx = repeat([:Subj1, :Subj2, :Subj3, :Subj4], inner=3)  # [1,1,1, 2,2,2, 3,3,3, 4,4,4]
item_idx = repeat([:Item1, :Item2, :Item3], outer=4)          # [1,2,3, 1,2,3, 1,2,3, 1,2,3]

# 2. Regression 1 Data (3 Fixed Effects)
# X1: Intercept + 2 Predictors
X1 = DimArray(hcat(ones(N), randn(N, 2)), (ObservationDim(1:N), fixed_effect_term_labels[At(:Regression1)]))

# Random Effect Design Matrices for Regression 1
# Factor 1 (Subject) uses 2 terms (e.g., Intercept and first Predictor)
Z1_f1 = X1[:, 1:2]
# Factor 2 (Item) uses 1 term (e.g., Intercept)
Z1_f2 = X1[:, 1:1]

# 3. Regression 2 Data (5 Fixed Effects)
# X2: Intercept + 4 Predictors
X2 = DimArray(hcat(ones(N), randn(N, 4)), (ObservationDim(1:N), fixed_effect_term_labels[At(:Regression2)]))

# Random Effect Design Matrices for Regression 2
# Factor 1 (Subject) uses 3 terms (e.g., Intercept and first two Predictors)
Z2_f1 = X2[:, 1:3]
# Factor 2 (Item) uses 0 terms (As specified in your evaluation: empty vector)
Z2_f2 = X2[:, []]

# Summarize for the model
fixed_effect_design_matrices = DimArray([X1, X2], regression_labels)
random_effect_design_matrices = DimArray([
    DimArray([Z1_f1, Z1_f2], random_effect_factor_labels), # Reg 1: Factor 1, Factor 2
    DimArray([Z2_f1, Z2_f2], random_effect_factor_labels)  # Reg 2: Factor 1, Factor 2
], regression_labels)

level_labels = DimArray([
    #Regression 1
    DimArray([subj_idx, item_idx], random_effect_factor_labels),
    #Regression 2
    DimArray([subj_idx, item_idx], random_effect_factor_labels)
    ], regression_labels)

predictors = RegressionPredictors(fixed_effect_design_matrices, random_effect_design_matrices, level_labels)

coefficients = rand(priors)

outcomes = linear_prediction(predictors, coefficients)


new_predictors = update_predictor(predictors, zeros(N), :Term3, :Regression1)
new_predictors = update_predictor(new_predictors, zeros(N), :Term2)

update_predictor!(new_predictors, ones(N), :Term2, :Regression2)
update_predictor!(new_predictors, ones(N), :Term4)




#################################
### EVALUATION: TURING MODELS ###
#################################

## 1. Simple model ##
@model function m1(predictors::RegressionPredictors, priors::RegressionPriors)

    # 1. Sample coefficients
    coefficients ~ priors

    # 2. Calculate outcomes
    outcomes = linear_prediction(predictors, coefficients)

    # 3. Here the likelihood would come

end

model = m1(predictors, priors)

chain = sample(model, Prior(), 1000, chain_type=VNChain)






## 2. Model using generated predictors ##
@model function m2(predictors::RegressionPredictors, priors::RegressionPriors)

    ## 0. Extract model information ##
    labels = priors.specifications.labels

    ## 1. Sample coefficients ##
    coefficients ~ priors

    ## 2. Extract information ##
    # Extract coefficients
    #Vector (R regressions) of vectors (P fixed effect terms)
    fixed_effects = get_fixed_effects(coefficients)
    #Vector (R regressions) of vectors (F factors) of matrices (J random effect levels, Q_total random effect terms)
    random_effects = get_random_effects(coefficients)

    ## 3. Calculate the outcomes for the first regression ##
    outcomes_1 = linear_prediction(
            fixed_effects, 
            random_effects, 
            predictors, 
            labels, 
            :Regression1, 
        )

    ## 4. Overwrite Term2 with the outcomes ##
    new_predictors = update_predictor(predictors, outcomes_1, :Term2)

    ## 5. DO the other regression using the new predictor ##
    outcomes_2 = linear_prediction(
            fixed_effects, 
            random_effects, 
            new_predictors, 
            labels, 
            :Regression2, 
        )

    # 3. Here the likelihood would come

end

model = m2(predictors, priors)

chain = sample(model, Prior(), 1000, chain_type=VNChain)





## 3. Model using generated predictors, and updating them by mutation ##
@model function m3(predictors::RegressionPredictors, priors::RegressionPriors)

    ## 0. Extract model information ##
    labels = priors.specifications.labels

    ## 1. Sample coefficients ##
    coefficients ~ priors

    ## 2. Extract information ##
    # Extract coefficients
    #Vector (R regressions) of vectors (P fixed effect terms)
    fixed_effects = get_fixed_effects(coefficients)
    #Vector (R regressions) of vectors (F factors) of matrices (J random effect levels, Q_total random effect terms)
    random_effects = get_random_effects(coefficients)

    ## 3. Calculate the outcomes for the first regression ##
    outcomes_1 = linear_prediction(
            fixed_effects, 
            random_effects, 
            predictors, 
            labels, 
            :Regression1, 
        )

    ## 4. Overwrite Term2 with the outcomes ##
    update_predictor!(predictors, outcomes_1, :Term2)

    ## 5. DO the other regression using the new predictor ##
    outcomes_2 = linear_prediction(
            fixed_effects, 
            random_effects, 
            predictors, 
            labels, 
            :Regression2, 
        )

    # 3. Here the likelihood would come

end

model = m3(deepcopy(predictors), priors)

chain = sample(model, Prior(), 1000, chain_type=VNChain)


